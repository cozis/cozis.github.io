<html>
	<head>
		<link rel="stylesheet" href="style.css" media="screen" />
		<title>Cozis - Scriviamo un web server!</title>
	</head>
	<body>
		<a href="intro.html">Indice</a>

		<h1>Scriviamo un web server HTTP/0.9 in C!</h1>
		<p>In questa guida intendo mostrare come si può creare una prima versione di web server in C su Linux.</p>

		<h2>1. Un po' di teoria..</h2>

		<h3>1.1 Ma cos'è un web server?</h3>
		<p>In generale, un'architettura client-server di un sistema software è quella in cui c'è un programma chiamato client che manda delle "richieste" ad un'altro chiamato server, che eventualmente manda delle "risposte" al primo. In generale, le richieste possono essere qualsiasi cosa.</p>

		<p>Nel caso dei web server, quello che è scambiato fra client e server sono file, o, più in generale, testo. Per far si che avvenga una comunicazione di successo fra client e server, questi devono essere d'accordo a priori su come comunicare, ossia devono condividere lo stesso protocollo. Nel caso dei <i>web</i> server, il protocollo è chiamato <b>HyperText Transfer Protocol</b> (<b>HTTP</b>). Il protocollo HTTP è un protocollo di trasferimento di ipertest, cioè file collegati fra di loro mediante quelli che comunemente chiamiamo <i>link</i>.</p>

		<h3>1.2 Il protocollo HTTP</h3>
		<p>Questo protocollo ha acquisito una grande importanza negli anni ed è stato messo a dura prova dalle esigenze della società. Basta immaginare che il web, nato per scambiare documenti testuali, è praticamente diventato una piattaforma di scambio di applicazioni molto sofisticate. Per questo motivo ha subito una grande trasformazione. Quindi il protocollo ha varie vesioni (HTTP/0.9, HTTP/1.0, HTTP/1.1, HTTP/2, HTTP/3) che diventano esponenzialmente più sofisticate perchè cercano di risolvere problemi sempre più particolari. L'impressione che ho è che la versione più in uso sia ancora HTTP/1.1.</p>

		<p>In questa guida, guarderemo solo la prima versione. Una richiesta HTTP/0.9 ha la forma</p>
		<textarea disabled>GET file.txt</textarea>
		<p>dove al posto di file.txt può esserci un qualsiasi nome di file. Il server, a sua volta, rispondera con il contenuto del file. La risposta del server deve essere HTML. Se qualcosa va storto (ad esempio il file non esiste), allora l'errore può essere comunicato al client in formato HTML. Una volta avvenuta la risposta, la transazione è conclusa con la chiusura della connessione da parte del server.</p>

		<h2>2. Programmiamo!</h2>
		<p>Il modo in cui procederemo è scrivendo un web server e poi effettuando richieste con il nostro browser preferito (Firefox, chrome, brave?).</p>

		<h3>2.1 Creiamo un server TCP</h3>

		<p>Un server HTTP è usualmente implementato su una connessione TCP aperta sulla porta 80.</p>

		<textarea disabled>
int main()
{
	int port = 80;

	// Chiediamo al sistema operativo di aprire un socket TCP.
	int fd = socket(AF_INET, SOCK_STREAM, 0);

	if(fd < 0)
		{
			fprintf(stderr, "Non sono riuscito ad aprire il socket!\n");
			return -1;
		}

	// Ora specifichiamo al sistema operativo a quale indirizzo
	// (e porta) vogliamo ascoltare per le richieste. La porta
	// alla quale siamo interessati è la 80, mentre per l'indirizzo
	// IP ci va bene qualsiasi sia a nostra disposizione, quindi
	// usiamo INADDR_ANY.
	{
		struct sockaddr_in addr;
		memset(&addr, 0, sizeof(struct sockaddr_in));
		addr.sin_family = AF_INET;
		addr.sin_port   = htons(port);
		addr.s_addr.sin_addr = INADDR_ANY;

		if(bind(fd, (struct sockaddr*) &addr, sizeof(addr)))
			{
				fprintf(stderr, "Non sono riuscito ad associare il socket all'indirizzo.\n");
				
				close(fd);
				return -1;
			}
	}

	// Ora cominciamo ad ascoltare le richieste.
	if(listen(fd, 8))
		{
			fprintf(stderr, "Non sono riuscito ad cominciare ad ascolare.\n");
			
			close(fd);
			return -1;
		}

	// ..Ora siamo pronti a ricevere richieste.

	while(1)
		{
			// Quel che dobbiamo fare qui è:
			//   1. Accettare la connessione con un client.
			//   2. Leggere la richiesta.
			//   3. Rispondere.
			//   4. Chiudere la connessione.
			//   5. Tornare al passo 1.
		}

	// Ora chiudiamo il socket.
	close(fd);

	// NOTA: In effetti chiudere il socket è inutile dato che
	//       il loop precedente non terminerà mai, ma noi lo
	//       facciamo comunque perchè è una buona abitudine.
	return 0;
}
		</textarea>
		<p>Per sapere di più sulle funzioni <code>socket</code>, <code>bind</code> e <code>listen</code> basta cercare su internet <code>man nomefunzione</code> (<i>man</i> è l'abbreviazione di <i>manual pages</i>).
		Ora ci possiamo occupare del cuore del problema, cioè ricevere, interpretare e gestire le richieste.</p>

		<p>Ora guardiamo meglio quel loop infinito:</p>

		<textarea disabled>
while(1)
	{
		// Quel che dobbiamo fare qui è:
		//   1. Accettare la connessione con un client.
		//   2. Leggere la richiesta.
		//   3. Rispondere.
		//   4. Chiudere la connessione.
		//   5. Tornare al passo 1.
	}
		</textarea>

		<p>Questo lo espandiamo in</p>

		<textarea disabled>
while(1)
	{
		// Quel che dobbiamo fare qui è:
		//   1. Accettare la connessione con un client.

		int cfd;
		{
			struct sockaddr_in addr;
			socklen_t          size = sizeof(addr):

			int cfd = accept(fd, (struct sockaddr*) &addr, size);

			if(cfd < 0)
				{
					// Uops! Qualcosa è andato storto mentre cercavamo
					// di accettare una nuove connessione. 

					// Continuiamo con la prossima richiesta.
					continue; // Torna dinuovo al passo 1.
				}
		}
		
		//   2. Leggere la richiesta.
		
		char buffer[256];
		int n;
		{		
			// Assumiamo che il contenuto della richiesta non può contenere più 
			// di 255 caratteri. Questo numero è arbitrario e, fondamentalmente,
			// si basa su quanto crediamo che saranno lunghi i nomi dei file
			// contenuti nelle richieste. Abbiamo fatto si che il buffer avesse
			// un byte in più rispetto al massimo in modo da capire se il client
			// ha mandato una richiesta più grande del dovuto.

			// Leggiamo nel buffer il contenuto della richiesta.
			n = read(cfd, buffer, sizeof(buffer));

			// Se un errore è avvenuto, allora [n] è negativo. Se il client si è
			// disconnesso prima di inviare qualcosa, allora [n] è zero. Altrimenti
			// [n] è pari al numero di byte copiati nel buffer. Se il buffer è
			// completamente riempito, è possibile che il client abbia inviato più
			// dati di quelli che potevano entrare nel buffer. Questi dati in più
			// avremmo potuti leggerli chiamando una seconda volta [read]. Noi però
			// non siamo interessati a farlo.

			if(n < 0)
				{
					// Abbiamo avuto problemi durante la lettura.
					// Chiudiamo la connessione e torniamo al passo 1.
					close(cfd);
					continue;
				}

			if(n == 0)
				{
					// Il client si è disconnesso prima di ricevere la 
					// risposta.
					// Chiudiamo la connessione e torniamo al passo 1.
					close(cfd);
					continue;
				}
		
			// Ok, abbiamo letto [n] byte. Se [n] è pari alla dimensione
			// del buffer (quindi è più lunga del massimo, cioè la dimensione
			// del buffer meno 1), allora dobbiamo comunicare al client
			// l'errore. Questo però lo facciamo nella prossima fase.
		}

		//   3. Rispondere.

		if(n == sizeof(buffer))
			{
				// Il client ha mandato una richiesta troppo grande.
				..
			}
		else
			{
				// Il client ha inviato la quantità giusta di dati
				// perchè il 256-esimo byte non è stato usato. Per
				// questo motivo sappiamo di poter mettere uno zero
				// alla fine dei contenuti del buffer per renderlo 
				// una valida stringa C.

				buffer[n] = '\0';

				// Se non avessimo deciso di aggiungere un byte in
				// più al buffer, allora nel caso in cui tutto il
				// buffer fosse usato non avremmo avuto lo spazio
				// per uno zero finale.

				// Il buffer deve contenere una cosa del tipo "GET xyz",
				// dove "xyz" è una qualsiasi stringa di caratteri
				// non contenente spazi.

				// Notiamo che nel buffer c'è almeno un carattere.
				assert(n > 0);

				// Sappiamo che la richiesta, per essere valida, deve
				// contenere come minimo 5 caratteri, perchè "GET" e
				// lo spazio successivo sono 4, e il nome del file
				// deve avere come minimo dimensione 1.

				if(n < 5)
					{
						// Richiesta non valida
						..
					}

				// Ora possiamo assicurarci che cominci con "GET"
				// seguito da uno spazio.

				if(buffer[0] != 'G' || buffer[1] != 'E' || buffer[2] != 'T' || isspace(buffer[3]))
					{
						// Richiesta non valida
						..
					}

				// Dalla posizione 4 in poi ci aspettiamo una sequenza
				// di caratteri fino a quando non raggiungiamo uno spazio
				// o la fine del buffer.

				int indice_inizio_percorso = 4;

				int i = 4;
				while(i < n && !isspace(buffer[i]))
					i += 1;

				int indice_fine_percorso = i;

				if(i < n)
					{
						assert();
						..
					}

				char *file = buffer + 4;

			}
		..

		//   4. Chiudere la connessione.
		close(cfd);

		//   5. Tornare al passo 1.
	}
		</textarea>
		<script src="scripts.js"></script>
	</body>
</html>