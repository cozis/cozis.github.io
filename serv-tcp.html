<html>
	<head>
		<link rel="stylesheet" href="style.css" media="screen" />
		<title>Cozis - Scriviamo server TCP</title>
	</head>
	<body>
		<a href="index.html">Indice</a>

		<h1>1. Scriviamo un server TCP in C!</h1>
		<p>In questa guida intendo mostrare come si può creare un server TCP in C su Linux. Questa guida spallidisce al confronto con altre che sono reperibili su internet, ma per completezza, relativamente ad altre guide di questo blog (come quelle sui web server), ho deciso di scriverla comunque. Anche perchè, nonostante la quantità di contenuti reperibili sia infinita, sono per lo più in inglese.</p>

		<p>I requisiti necessari per seguire questa guida sono:</p>
		<ul>
			<li>Un po' di esperienza con il linguaggio C.</li>
			<li>Un sistema Linux.</li>
		</ul>
		<p>Ciascuno degli elementi di questa lista può essere sostituito con un'adeguata dose di buona volontà, se necessario!</p>

		<h2>Sommario</h2>
		<ol>
			<li>Scriviamo un server TCP in C!</li>
			<li>Teoria!</li>
			<ol>
				<li>Cos'è un server? Cos'è TCP? Cos'è un server TCP?!</li>
			</ol>
			<li>Programmiamoo</li>
			<ol>
				<li>I socket</li>
				<li>Il binding</li>
			</ol>
		</ol>

		<h2>2. Teoria!</h2>

		<h3>2.1. Cos'è un server? Cos'è TCP? Cos'è un server TCP?!</h3>

		<p>I computer possono comunicare fra loro inviandosi arbitrarie sequenze di byte. Su due piedi uno penserebbe che questi canali di comunicazione possono avvenire quando i due computer contemporaneamente scelgono di interagire. Pensandoci attentamente però, la comunicazione può avvenire solo quando uno dei due nodi sceglie di cominciare la comunicazione con l'altro, unidirezionalmente. Quindi uno dei due deve essere sempre in attesa di connessioni. Del resto è così anche con i telefoni cellulare. Ciascuno di noi è perennemente in attesa di chiamate (o almeno quando il telefono è acceso) in modo tale che nell'esatto momento in cui qualcuno vuole chiamarci, anche noi siamo pronti per la comunicazione. Se noi avessimo il cellulare spento accetto quando vogliamo ricevere una chiamata, e gli altri ci provassero a chiamare quando vogliono interagire, probabilmente non riusciremmo mai a parlare! Per questo motivo uno dei computer deve essere sempre in ascolto per connessioni mentre è l'altro che decide quando cominciare la comunicazione. In questo contesto, il computer che è sempre pronto ad interagire è chiamato <b>server</b>, mentre l'altro è chiamato <b>client</b>. Un esempio di questa architettura sono il browser e le macchine che mantengono i siti web. Il browser sono i client e le macchine che mantengono i siti sono i server. Questi server mantengono i siti e lo mandano ad ogni client che lo chiede.</p>

		<p>Per far avvenire questa comunicazione, i computer devono essere collegati fisicamente con dei cavi. Una volta collegati, a ciascun computer è associato un identificativo univoco (noto come indirizzo IP) che può essere usato per contattarlo. A questo punto è necessario fare un'ulteriore considerazione. In effetti, quando diciamo che due computer stanno comunicando, in realtà sono due programmi su questi computer che stanno comunicando. Ma su un computer possono girare più di un programma, quindi un identificativo all'intero computer non basta. È necessario introdurre un identificativo aggiuntivo per i vari programmi all'interno di ciascun computer che ha a sua volta un identificativo. L'identificativo del programma è detto porta, mentre quello del computer è detto indirizzo. Un programma, per avviare la comunicazione con un programma remoto, deve conoscere la coppia (indirizzo, porta) di quest'ultimo. Usualmente per spiegare quest'idea si usa la metafora secondo la quale la rete internet è una città, dove ciascun palazzo è un computer ed ogni camera del palazzo è un programma. Per andare da casa nostra a quella di un nostro amico, abbiamo bisogno di indirizzo e numero di porta.</p>

		<font color="red">Come è fatto un indirizzo? Ed una porta? E cosa sono le "reti" in generale?</font>

		<p>Il TCP è uno dei protocolli che permette la comunicazione di questi byte. Questa è una descrizione molto astratta, ma per fortuna ci basta sapere questo dato che il sistema operativo si occupa dei dettagli per noi. Esistono altri protocolli, come ad esempio l'UDP, ma al momento non ci interessano.</p>

		<p>Quindi, finalmente, <b>un server TCP è un programma che ascolta su una determinata porta per connessioni TCP</b> di altri computer.</p>

		<h2>3. Programmiamoo</h2>
		
		<p>
			Un programma che implementa un server TCP deve fare le seguenti cose:
		</p>

			<ol>
				<li>Creare un socket</li>
				<li>Associare il socket ad un indirizzo ed una porta</li>
				<li>Cominciare ad ascoltare per richieste</li>
				<li>Leggere le richieste</li>
				<li>Inviare risposte</li>
			</ol>

		<p>
			Quindi, in prima approssimazione, avremo una cosa del genere (in pseudo-codice):
		</p>

		<textarea disabled>
socket = create_TCP_socket()

set_address_and_port(socket, address, port)
		
listen(socket)
		
while true
	{
		connection = accept(socket)

		request = read(connection)

		response = build_response(request)

		send(connection, response)
	}</textarea>

		<h3>3.1. I socket</h3>
		<p>
			Hei hei hei! Aspetta un attimo!! Ed ora cos'è 'sto socket?! Vi starete chiedendo..
		</p>
		<p>
			I socket sono un'astrazione del sistema operativo che permette ai programmatori di non dover pensare ai dettagli implementativi dei meccanismi che permettono la comunicazione fra computer. Invece di pensare a driver della scheda di rete, buffer di input e buffer di output, ci basta pensare "ok, ora apriamo un socket!".
		</p>
		<p>Su Linux, un socket si crea usando la funzione <code>socket</code> definita in <code>sys/socket.h</code></p>

		<textarea disabled>
#include <sys/socket.h>

int socket(int domain, int type, int protocol);</textarea>

		<p>
			L'argomento <code>domain</code> fa riferimento al dominio del socket. Questo può essere <code>AF_INET</code> per la comunicazione fra due computer diversi, oppure <code>AF_UNIX</code> per la comunicazione fra due processi di uno stesso computer. L'argomento <code>type</code> fa riferimento al tipo del socket. Qui è dove specifichiamo di volere un socket TCP fornendo il valore <code>SOCK_STREAM</code>. Infine, l'argomento <code>protocol</code> onestamente non ci interessa. Possiamo fornire un bel 0. Questa funzione ritorna l'identificativo del nostro socket. Se invece la funzione per qualche motivo fallisce, un valore negativo è ritornato. Questo identificativo ci servirà per affettuare operazioni sul socket come leggere e scrivere byte dalla connessione. Quando il socket non ci serve più, possiamo chiuderlo chiamando la funzione <code>close</code>
		</p>

		<p>La prima parte del nostro server TCP quindi diventa:</p>

		<textarea disabled>
#include <sys/socket.h>

int main()
{
	// Apriamo il socket.
	int fd = socket(AF_INET, SOCK_STREAM, 0);

	if(fd < 0)
		{
			fprintf(stderr, "La creazione del socket è fallita!\n");
			return -1;
		}

	// ..facciamo cose col socket..

	// Ed ora lo chiudiamo.
	close(fd);

	return 0;
}</textarea>

		<p>
			NOTA: Spesso si usa <code>fd</code> come nome della variabile del socket (in generale degli identificativi relativi a strutture dati interne al kernel di Linux) perchè sta per <i>File Descriptor</i>. In Linux, ogni cosa è vista come un file dal quale si può leggere e scrivere, anche i socket.
		</p>

		<h3>3.2. Il binding</h3>

		<p>A questo punto dobbiamo effettuare quello che si chiama <i>binding</i>, cioè l'associazione del socket ad un indirizzo ed una porta. Potrebbe sorgere spontanea la domanda "perchè devo dire al socket qual è il mio indirizzo, se il computer dovrebbe già conoscerlo?". La risposta a questa domanda è che i computer possono avere più indirizzi allo stesso tempo (probabilmente non è il nostro caso però!). La funzione che ci permette di fare il binding è:</p>

		<textarea disabled>
#include <sys/socket.h>

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</textarea>
	
		<p>
			Alle persone non abituate alle stranezze del C questa funzione potrebbe sembrare un po' strana.. (Ho visto cose.. che voi umani.. non potete neanche immaginare). Il modo in cui si usa questa funzione è definendo una struttura del tipo <code>struct sockaddr_in</code> (definita in <code>netinet/in.h</code>), riempirne i valori e poi passarne il puntatore a <code>bind</code>. Ecco la stranezza però: il puntatore che <code>bind</code> si aspetta, può essere di altri tipi oltre che a <code>struct sockaddr_in</code> (come ad esempio <code>struct sockaddr_un</code> quando la connessione è fra processi locali). Per questo motivo la funzione <code>bind</code> definisce il tipo <code>struct sockaddr</code> che è un tipo opaco che rappresenta il fatto che uno dei tipi <code>struct sockaddr_*</code> deve essere fornito.
		</p>

		<p>
			Il primo argomento <code>sockfd</code> è il descrittore del nostro socket (quello che ci ha dato <code>socket</code>), il secondo è il puntatore alla struttura <code>struct sockaddr_in</code> che contiene indirizzo e porta, mentre l'ultimo argomento è la dimensione della struttura della quale abbiamo fornito il puntatore come secondo argomento (quindi <code>sizeof(struct sockaddr_in)</code>, nel nostro caso).
		</p>

		<p>La struttura che mantiene indirizzo e porta è fatta così:</p>

		<textarea disabled>
#include <netinet/in.h>

struct sockaddr_in {
    short            sin_family;
    unsigned short   sin_port;
    struct in_addr   sin_addr;
    char             sin_zero[8];
};

struct in_addr {
    unsigned long s_addr;
};</textarea>

		<p>Il campo <code>sin_family</code> deve sempre mantenere il valore <code>AF_INET</code>, il campo <code>sin_port</code> mantiene il valore della nostra porta (un numero compreso fra 0 e 2^16-1 = 65535) ed infine <code>sin_addr</code> contiene il nostro indirizzo (un numero compreso fra 0 e 2^32-1). Il campo <code>sin_zero</code> non ci interessa e ci limitiamo a riempirlo di zeri.</p>

		<p>C'è solo un ultimo dettaglio da chiarire prima di poter fare il binding. I valori di porta ed indirizzo non possiamo assegnarli come se niente fosse. Esiste una cosa chiamata <code>network byte ordering</code>, che è legata al modo in cui la CPU ordina i byte in memoria (<i>little endian</i> e <i>big endian</i>). Supponiamo di avere un intero binario rappresentato in 4 byte (32 bit) N = A B C D, (dove A,B,C,D sono 4 possibili configurazioni di byte) e di volerlo salvare in memoria ad un indirizzo P. Un computer <i>little endian</i> salva N come</p>

		<table class="memory">
			<tr>
				<td>P</td>
				<td>P+1</td>
				<td>P+2</td>
				<td>P+3</td>
			</tr>
			<tr>
				<td>D</td>
				<td>C</td>
				<td>B</td>
				<td>A</td>
			</tr>
		</table>

		<p>mentre un computer <i>big endian</i> lo salva come</p>

		<table class="memory">
			<tr>
				<td>P</td>
				<td>P+1</td>
				<td>P+2</td>
				<td>P+3</td>
			</tr>
			<tr>
				<td>A</td>
				<td>B</td>
				<td>C</td>
				<td>D</td>
			</tr>
		</table>

		<p>Se un computer <i>big endian</i> ed uno <i>little endian</i> comunicano con un socket senza compensare per questa incompatibilità, allora inviando dati più grandi di un byte ci saranno corruzioni dei dati dovuti al fatto che uno dei computer invierà un valore N = ABCD e l'altro lo leggerà come N = DCBA. Per risolvere questo problema si fissa come convenzione l'ordinamento di byte della rete e tutti i computer che vi partecipano devono adattarsi. Questo convenzione è detta <i>network byte order</i>. <b>Il protocollo TCP definisce l'ordinamento byte della rete come <i>big endian</i></b>.</p>

		<h2>Fonti</h2>
		<ul>
			<li><a href="https://man7.org/linux/man-pages/man2/socket.2.html">https://man7.org/linux/man-pages/man2/socket.2.html</a></li>
			<li><a href="https://man7.org/linux/man-pages/man2/bind.2.html">https://man7.org/linux/man-pages/man2/bind.2.html</a></li>
			<li><a href="https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-bind-bind-name-socket">https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-bind-bind-name-socket</a></li>
			<li><a href="https://www.gta.ufrj.br/ensino/eel878/sockets/sockaddr_inman.html">https://www.gta.ufrj.br/ensino/eel878/sockets/sockaddr_inman.html</a></li>
			<li><a href="https://www.ibm.com/docs/en/zos/2.4.0?topic=hosts-network-byte-order">https://www.ibm.com/docs/en/zos/2.4.0?topic=hosts-network-byte-order</a></li>
		</ul>
		---------------------
		Potrebbero anche interessarti:
		...
		...

		<script src="scripts.js"></script>
	</body>
</html>